= Raider Robotics Coding Guide
Coding Resources for Raider Robotics (Team 4698)
:source-highlighter: highlight.js
:xrefstyle: short
:sectnums:
:toc:

== Getting Started

NOTE: Programming a robot requires both software development skills and a good familiarity with the hardware connected to the robot.  The integration of both the hardware and the software can make robot programming very challenging.  It is *NOT* easy but don't get discouraged.

Team 4698 competes in the FIRST Robotics Competition (FRC).  FRC provides many software tools and programming libraries that are used to create the program that runs on the robot's controller. It is possible to program using LabVIEW, Java, or *pass:[C++]*.  Our team writes the robot program in the *pass:[C++]* programming language.  As a first starting point, a basic understanding of *pass:[C++]* is necessary.  There are good resources online for learning *pass:[C++]* such as https://learncpp.com/[`learncpp.com`^].  Chapters 0-8 and 13-18 will cover most all of what you will need for Robot programming.  It will be very helpful to have a Windows computer (preferably a laptop) that you can install a *pass:[C++]* compiler on to run your code as you learn programming.  

Coding tips:

* Learn `namespaces` as FRC software uses them a lot
* Pay attention to class hierarchies and inheritance
 

=== FRC Game Tools Install

The FRC Game tools are the programs that handle the communication between the laptop and the robot.  The processor on the robot that controls all of the robot functions is called a RoboRIO.  The RoboRIO connects to the laptop in one of three ways: A USB cable, an ethernet cable, or wirelessly.  The RoboRIO is connected to a wireless bridge that creates a WiFi network.

The main application is the `Driver Station`.  It connects to the RoboRIO and can enable and disable the robot.  It also handles the joystick inputs to the robot and displays statistics and logging information about the robot's status.

The FRC Games Tools need to be installed before other components and libraries are installed.  The directions for installing are: https://docs.wpilib.org/en/stable/docs/zero-to-robot/step-2/frc-game-tools.html[Installation instructions for the FRC Game Tools^]. You do not need to install anything for LabVIEW or Java since we do not use those programming languages.

=== WPILib Library Install

The software library that FRC uses in called WPILib.  WPILib is very large and contains many elements including hardware interfacing, control systems, networking, and vision processing.  The Microsoft VSCode compiler and Integrated Development Environment (IDE) are installed when the WPILib software is installed.  This should be installed after the FRC Game Tools.  https://docs.wpilib.org/en/stable/docs/zero-to-robot/step-2/wpilib-setup.html[Installation Instructions^]

Some of the motors and motor controllers require software libraries that don't come in the WPILib libraries.  We use hardware that require the Rev Robotics REVLib library and the CTRE Phoenix Framework.  https://docs.wpilib.org/en/stable/docs/software/vscode-overview/3rd-party-libraries.html[Information on installing these libraries^].

== Hardware Overview

=== RoboRIO


=== Motors

There are two types of motors used in FRC, https://en.wikipedia.org/wiki/Brushed_DC_electric_motor[brushed^] motors and https://en.wikipedia.org/wiki/Brushless_DC_electric_motor[brushless^] motors.  

Brushed motors are very simple electrically and inexpensive but have "brushes" than slide on  the rotation shaft of the motor and can wear faster than a brushless motor.  They have much lower power-to-weight ratios than brushless motors as well.  Brushed motors only have two wires, usually red and black.  Reversing the polarity of the wires reverses the direction of the motor.

Brushless motors are much more electrically complex but mechanically simpler.  Brushless motors have three wires that cannot be connected directly to a battery.  Due to the complicated control needed for brushless motors they must have an encoder built into them to function correctly (See <<_encoders>>) and they must be connected to a brushless motor controller (sometimes called a "Smart Controller").  Having a built-in encoder makes brushless motors work with complex motion control without having to add an external encoder. The *Falcon* motor from CTRE has the controller built into the motor in addition to the encoder.  It is a complete control system module.

=== Encoders

Encoders are devices that measure the rotation of a shaft.  Usually encoders are either built into motors or added to the motor shaft but it is also possible to add an encoder to any rotating shaft.  Encoders have a resolution which is specified in `tics` per rotation.  The *Falcon* motor has a built-in encoder which has a resolution of 2048.  That means that it can detect rotations of 360 / 2048 = 0.176 degrees.

Encoders are either "relative encoders" or "absolute encoders".  Most encoders are relative which means that the encoder doesn't know where the motor shaft is physically but only knows how far it has turned since it was powered on. An absolute encoder on the other hand knows where a zero position is in the rotation even when power is lost and restored.

=== Gyros / IMUs

Gyros measure the rotation around an axis by sensing inertial movement.  They essentially detect their acceleration and integrate that to determine the angle of rotation.  All but the simplest gyros are actually Inertial Measurement Units (IMUs) which measure rotation and acceleration around three orthogonal axes (3-axis gyro).  They also usually have a magnetometer (i.e. compass) as well.  Because an IMU has to communicate so much information to the robot, it is usually connected via CANbus or SPI.

=== Switches

Typical application of switches in robotics are limit switches.  They are triggered when a moving part of the robot get to the end point of it's travel.

=== PWM

Pulse Width Modulation (PWM) is a way to send a varying signal (like an absolute encoder position) over a digital channel.  See https://learn.sparkfun.com/tutorials/pulse-width-modulation/all[SparkFun PWM Page^]

=== AnalogIO

It is also possible to read (or output) an analog signal.  An analog signal is one that can vary from 0V - 12V.

== Robot Program

The Driver Station controls what part of the robot program is allowed to run and whether the motor can be activated.  During a competition, control of the Driver Station is taken over by the competition system and they control what the robot can do.

There are three modes that the robot can be in: "TeleOperated", "Autonomous", and "Test".  TeleOperated mode is when the driver can control all functions of the robot.  Autonomous mode is when the robot code can run but it cannot take input from the Driver Station controllers. Test mode is for testing motors and sensors during setup and practice. A typical competition round will consist of some amount of time in Autonomous mode and then switch to TeleOperated mode for the rest of the round.

=== Robot Program Structure

When you write a program to control the robot you are actually just writing some subset of the program that is actually running on the RoboRIO.  The WPILib is actually controlling the control flow of the program and calls your code at certain times during its execution.  It basically gives you control every so often and you must do something while you have control and return control back without taking too much time.

WPILib provides two main ways to structure a robot program. One is called "TimedRobot" based and the other is "Command" based.  Both program structures have methods that are called by the WPILib scheduler but when and how those methods are called differ between the two program structures.



[#units]
=== Units Library
The Units Library is very powerful and useful for robot programming.  It is a bit difficult to learn and understand initially but it will help keep your code's units consistent. Read the https://docs.wpilib.org/en/stable/docs/software/basic-programming/cpp-units.html[FRC Units Library Documentation^] to get an overview.

One of the more useful aspects of using the Units Library is being able to define custom units that pertain to your robot code.  For example, using the *TalonFX* smart motor controller library's `Set()` function requires the position or velocity inputs in very awkward units (See <<talon_pid_table>>). The position should be in "encoder tics" and the velocity should be in "encoder tics" per 100 milliseconds. There are 2048 encoder tics per rotation for the *TalonFX* built-in encoder. Custom units can help with converting from these strange units to more physically meaningful units. You could define a custom angular position unit that is ("tics") and a custom angular velocity unit that is ("tics" / 100_ms).

[source,C++]
----
        // Create a unit called "tics" that represents 1/2048th of a revolution
        // and make a type qualifier called "tics_t"
    typedef units::unit<std::ratio<1,2048>, units::turns> tics;
    typedef units::unit_t<tics> tics_t;

        // Create a unit called "tics_per_100ms" that represents (tics / 0.1 seconds)
        // and make a type qualifier called "tics_per_100ms_t"
    typedef units::compound_unit<tics, units::inverse<units::deciseconds>> tics_per_100ms;
    typedef units::unit_t<tics_per_100ms> tics_per_100ms_t;

        // Alternatively "tics_per_100ms" could be defined as:
        // typedef units::compound_unit<tics, units::inverse<
        //         units::unit<std::ratio<1,10>, units::seconds>>> tics_per_100ms;
----

Once these types are defined then the programmer doesn't need to worry about converting from `tics` to degrees or from RPM to `tics_per_100ms`. The units types will do all the conversions automatically.  The code below shows how to use these types.

[source,C++]
----
tics_t talon_position;
tics_per_100ms_t talon_velocity;
ctre::phoenix::motorcontrol::can::TalonFX talon{2};

    // This automatically converts from degrees to tics
talon_position = 45_deg;

    // value() returns the position in tics as a double
    // which is 256 tics ( 45 * 2048 / 360 )
talon.Set( ctre::phoenix::motorcontrol::ControlMode::Position,
            talon_position.value() );

    // This automatically converts from RPM to tics_per_100ms.
talon_velocity = 2400_rpm;

    // value() returns the velocity in tics_per_100ms as a double
    // which is 8192 tics_per_100ms ( 2400 * 2048 / 600 )
talon.Set( ctre::phoenix::motorcontrol::ControlMode::Velocity,
            talon_velocity.value() );

    // If you need to convert a variable in one unit to another
    // without creating a variable you can use:
printf( "Talon Velocity = %7.2f rpm\n", 
        units::revolutions_per_minute_t(talon_velocity).value() );
    // This will print "Talon Velocity = 2000.00 rpm"
----

== Motion Control

Supose you want to control a flywheel that will be used to shoot a ball towards a target.  Suppose also that you need the ball to be going just the right speed so that it hits the target correctly.  The simplest thing that you could do is to put a certain voltage on the motor so the flywheel so it is going just the right speed to work.  This method is called "open-loop control" because you actually don't know how fast the motor is spinning but you adjusted the voltage so it "just works".  The problem with this method is that if the motor heats up or the battery drains or the temperature outside changes then the speed of the flywheel will change.  The only way to make it shoot correctly is to change the voltage that is sent to the motor.  It will always need to be tweaked to work.

A better technique is to use motion control.  The basic idea is to use a motor to move something and use some kind of sensor to control that movement in some way.  In the shooter example above we would have a sensor (encoder in this case) that could measure the RPMs of the flywheel. We then need to determine what RPM the shooter flywheel needs to spin to have the ball hit the target correctly.  Then we need to "make sure" that the flywheel is going the correct RPM when we want to shoot the ball.

=== PID Control Overview



==== PID Tuning

* https://docs.wpilib.org/en/stable/docs/software/advanced-controls/introduction/introduction-to-pid.html[Introduction to PID -- WPILib^]

* https://docs.wpilib.org/en/stable/docs/software/advanced-controls/introduction/tuning-pid-controller.html[Tuning a PID Controller -- WPILib^]

* https://docs.revrobotics.com/sparkmax/operating-modes/closed-loop-control[Closed Loop Control -- RevLib^]

* https://docs.ctre-phoenix.com/en/stable/ch16_ClosedLoop.html#closed-loop-configurations[Closed-Loop Configurations -- CTRE^]

https://www.youtube.com/watch?v=jIKBWO7ps0w[0 to Autonomous Video, Part 1]

https://www.youtube.com/watch?v=Z24fSBVJeGs[0 to Autonomous Video, Part 2]

[#pid_kv]
=== Software PID Units and `kV` Values

The WPILib `frc2::PIDController` class can use what units the programmer decides to use since the measurement values are passed into the `Calculate()` method.  Therefore the units of the PID constants will vary depending on the units used in the code. 

Each software vendor uses different units for their PID Controllers.  The table below summarizes the differences between the different vendor libraries in one place.

[cols="1,1,2"]
.Rev Robotics *SparkMAX* Onboard Controller Units
|===
| Control Type | Units | Configurable

| Duty Cycle | [-1,1] | 
| Voltage | [0,12] volts | 
| Position | rotations | setPositionConversionFactor()
| Velocity | RPM | setVelocityConversionFactor()
| Current | Amps | 
3+| *SparkMAX* feed forward `kFF` works the same as `kV` in WPILib. There is also an Arbitrary feed forward mechanism that is similar to `kS` in WPILib or can be customized (e.g. to vary with arm angle to compensate for varying gravity effect).
|===

[cols="2,3,4"]
.CTRE Phoenix *TalonFX* Onboard Controller Units
[[talon_pid_table]]
|===
| Control Type | Units | Conversion (2048 units/rev)

| Position | "units" (encoder tics)^[1]^ | divide by 2048 for rotations
| Velocity | "units" (tics) per 100ms^[1]^ | multiply by 600/2048 for RPM
| Current | Amps | 
3+| *TalonFX* feed forward `kFF` works the same as `kV` in WPILib. There is also an Arbitrary feed forward mechanism that is similar to `kS` in WPILib or can be customized (e.g. to vary with arm angle to compensate for varying gravity effect).  NOTE [1]: See <<units>> and Phoenix API in <<_resources>>.
|===

[cols="2,2,2,2,2,1"]
.Common Motor Specs and *kV* Values
|===
| Motor | Max Speed (rpm) | Power (W) | `kV` (Volts/RPM) | Encoder tics | Link

| Rev 775 | 18,500 rpm | 347 W | 1542 V/rpm | Brushed | https://www.vexrobotics.com/catalogsearch/result/?q=775[Vex^]
| Rev NEO | 5676 rpm | 540 W | 473 V/rpm | 42 | https://www.revrobotics.com/search.php?search_query=NEO[Rev^]
| Rev NEO 550 | 11,000 rpm | 279 W | 917 V/rpm | 42 | https://www.revrobotics.com/search.php?search_query=NEO[Rev^]
| Falcon 500 | 6380 rpm | 783 W | 532 V/rpm | 2048 | https://www.vexrobotics.com/catalogsearch/result/?q=Falcon[Vex^]

|===


== Network Tables

Can change values while robot code is running.

== Autonomous Control

"Self Driving Robot"

== Vision / Cameras

Limelight

Raspberry Pi


== Resources

* https://docs.wpilib.org/en/stable/index.html[WPILib Documentation^] 
(https://github.com/wpilibsuite/frc-docs[GitHub^])
* https://first.wpi.edu/wpilib/allwpilib/docs/release/cpp/index.html[WPILib *pass:[C++]* API^] 
(https://first.wpi.edu/wpilib/allwpilib/docs/release/cpp/namespacefrc.html[frc::^])
* https://docs.revrobotics.com/sparkmax/software-resources/spark-max-api-information[Rev Robotics REVLib Docs^] 
(https://codedocs.revrobotics.com/cpp/namespacerev.html[API^])

* https://docs.ctre-phoenix.com/en/stable/[CTRE Phoenix Framework Docs^] 
(https://api.ctr-electronics.com/phoenix/release/cpp/namespaces.html[API^,window=_blank^])
